// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define PI 3.14159265359

#define MAX_BLADE_SEGMENTS 5
#define MAX_BLADE_POINTS MAX_BLADE_SEGMENTS*2+1


float3 _CenterPositionWS;

struct SourceVertex {
    float3 positionOS;
};

StructuredBuffer<SourceVertex> _SourceVertices;
StructuredBuffer<int> _SourceTriangles;

struct DrawVertex {
    float3 positionWS;
    float height;
};

struct DrawTriangle {
    float3 lightingNormalWS;
    DrawVertex vertices[3];
};

AppendStructuredBuffer<DrawTriangle> _DrawTriangles;

struct IndirectArgs {
    uint numVerticesPerInstance;
    uint numInstances;
    uint startVertexIndex;
    uint startInstanceIndex;
};

RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;

int _NumSourceTriangles;

int _MaxBladeSegments;
float _MaxBendAngle;
float _BladeCurvature;
float _BladeHeight;
float _BladeHeightVariance;
float _BladeWidth;
float _BladeWidthVariance;

float _BladeDensity;

float4x4 _LocalToWorld;

// Returns a pseudorandom number. By Ronja Bohringer
float rand(float4 value) {
    float4 smallValue = sin(value);
    float random = dot(smallValue, float4(12.9898, 78.233, 37.719, 9.151));
    random = frac(sin(random) * 143758.5453);
    return random;
}

float rand(float3 pos, float offset) {
    return rand(float4(pos, offset));
}

float randNegative1to1(float3 pos, float offset) {
    return rand(pos, offset) * 2 - 1;
}

// A function to compute an rotation matrix which rotates a point
// by angle radians around the given axis
// By Keijiro Takahashi
float3x3 AngleAxis3x3(float angle, float3 axis) {
    float c, s;
    sincos(angle, s, c);

    float t = 1 - c;
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    return float3x3(
        t * x * x + c, t * x * y - s * z, t * x * z + s * y,
        t * x * y + s * z, t * y * y + c, t * y * z - s * x,
        t * x * z - s * y, t * y * z + s * x, t * z * z + c
        );
}
DrawVertex SetupBladePoint(float3 anchorWS, float2 dimensions, float3x3 tsToWs, float2 uv) {
    float3 offsetTS = float3((uv.x - 0.5f) *dimensions.x, 0, uv.y * dimensions.y);
    float3 offsetWS = mul(tsToWs, offsetTS);

    float3 positionWS = anchorWS + offsetWS;

    DrawVertex output = (DrawVertex)0;
    output.positionWS = positionWS;
    output.height = uv.y;

    return output;
}

float2 GetBladeDimensions(float3 positionWS) {
    float width = randNegative1to1(positionWS, 0) * _BladeWidthVariance + _BladeWidth;
    float height = randNegative1to1(positionWS, 1) * _BladeHeightVariance + _BladeHeight;

    return float2(width, height);
}

void GetTriangleNormalAndTSToWSMatrix(float3 a, float3 b, float3 c, out float3 normalWS, out float3x3 tangentToWorld) {
    // Calculate a basis for the tangent space
    // The tangent, or X direction, points from a to b
    float3 tangentWS = normalize(b - a);
    // The normal, or Z direction, is perpendicular to the lines formed by the triangle points
    normalWS = normalize(cross(tangentWS, c - a));
    // The bitangent, or Y direction, is perpendicular to the tangent and normal
    float3 bitangentWS = normalize(cross(tangentWS, normalWS));
    // Now we can construct a tangent -> world rotation matrix
    tangentToWorld = transpose(float3x3(tangentWS, bitangentWS, normalWS));
}

// Returns the center point of a triangle defined by the three arguments
float3 GetTriangleCenter(float3 a, float3 b, float3 c) {
    return (a + b + c) / 3.0;
}

void GetCenterAndBasis(SourceVertex a, SourceVertex b, SourceVertex c, out float3 positionWS, out float3 normalWS, out float3x3 tsToWS, out float surface)
{
    float3 positionA_WS = mul(_LocalToWorld, float4(a.positionOS, 1)).xyz;
    float3 positionB_WS = mul(_LocalToWorld, float4(b.positionOS, 1)).xyz;
    float3 positionC_WS = mul(_LocalToWorld, float4(c.positionOS, 1)).xyz;

    surface = length(cross( positionA_WS - positionB_WS, positionC_WS - positionB_WS )) / 2.f;

    positionWS = GetTriangleCenter(positionA_WS, positionB_WS, positionC_WS);

    GetTriangleNormalAndTSToWSMatrix(positionA_WS, positionB_WS, positionC_WS, normalWS, tsToWS);
}

void PickRandomPointInTriangle(SourceVertex a, SourceVertex b, SourceVertex c, int seed, out float3 positionWS) {
    float3 positionA_WS = mul(_LocalToWorld, float4(a.positionOS, 1)).xyz;
    float3 positionB_WS = mul(_LocalToWorld, float4(b.positionOS, 1)).xyz;
    float3 positionC_WS = mul(_LocalToWorld, float4(c.positionOS, 1)).xyz;

    float3 A = positionA_WS - positionB_WS;
    float3 B = positionC_WS - positionB_WS;

    float m1 = rand(float4(A,seed));
    float m2 = rand(float4(B,seed));
    if (m1+m2 > 1) {
        m1 = 1-m1;
        m2 = 1-m2;
    }

    positionWS = (m1*A + m2*B)+positionB_WS;

}

float3x3 FigureTransformationForHeight(float v, float3x3 twistMatrix, float3x3 tsToWs, float maxBend) {
    float3x3 bendMatrix = AngleAxis3x3(maxBend *v* _BladeCurvature, float3(1,0,0));
    return mul(tsToWs, mul(twistMatrix, bendMatrix));
}

[numthreads(128,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
   if (id.x >= _NumSourceTriangles)
      return;

   int triStart = id.x *3;
   float3 positionWS, normalWS;
   float3x3 tsToWs;
   float surface;


   GetCenterAndBasis(
       _SourceVertices[_SourceTriangles[triStart+0]],
       _SourceVertices[_SourceTriangles[triStart+1]],
       _SourceVertices[_SourceTriangles[triStart+2]],
       positionWS, normalWS, tsToWs, surface
   );

    if (dot(normalize(normalWS), float3(0,1,0)) < 0.7) return;

    int numBlades = 0;

    while ( numBlades < surface*_BladeDensity ) {

    PickRandomPointInTriangle( _SourceVertices[_SourceTriangles[triStart+0]],
       _SourceVertices[_SourceTriangles[triStart+1]],
       _SourceVertices[_SourceTriangles[triStart+2]], numBlades,
       positionWS);

    float2 dimensions = GetBladeDimensions(positionWS);

    float3x3 twistMatrix = AngleAxis3x3(rand(positionWS, 2) * PI * 2, float3(0,0,1));
    float maxBend =  _MaxBendAngle * (1/ pow(length(positionWS-_CenterPositionWS), 2)) *10;
    float3x3 bendMatrix = AngleAxis3x3(maxBend, float3(1,0,0));

    int numBladeSegments = min(MAX_BLADE_SEGMENTS, max(1, _MaxBladeSegments));

    DrawVertex vertices[MAX_BLADE_POINTS];

    for(int i=0; i < numBladeSegments; ++i) {
        float v = i / (float)numBladeSegments;
        float u = 0.5 - (1-v) * 0.5;

        float3x3 transform = FigureTransformationForHeight(v, twistMatrix, tsToWs, maxBend);

        vertices[i*2] = SetupBladePoint(positionWS, dimensions, transform, float2(u,v));
        vertices[i*2 +1] = SetupBladePoint(positionWS, dimensions, transform, float2(1-u,v));
    }
    float3x3 transform = FigureTransformationForHeight(1, twistMatrix, tsToWs, maxBend);
    vertices[numBladeSegments*2] = SetupBladePoint(positionWS, dimensions, transform, float2(0.5,1));

    int numTriangles = (numBladeSegments -1)*2 +1;
    for (int i=0; i<numTriangles; ++i) {
        DrawTriangle tri = (DrawTriangle)0;
        tri.lightingNormalWS = normalWS;
        tri.vertices[0] = vertices[i +0];
        tri.vertices[1] = vertices[i +1];
        tri.vertices[2] = vertices[i +2];
        _DrawTriangles.Append(tri);
    }

    InterlockedAdd(_IndirectArgsBuffer[0].numVerticesPerInstance, numTriangles* 3);

    numBlades +=1;
    }
}
